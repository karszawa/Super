# Today's topic

---

# 開発速度と品質を両立しながら開発を行うためにITPチームが何を行っているか

---

## 今日のまとめ

- 巨大なビジネスロジックの制御方法（何を作っているか）
- スクラムの実践方法（どうやって作っているか）

---

## ITP has **extremely** complex business requirements :shrug:

ITPは次の条件で振る舞いを変える

- **購入者** か **出品者**
- **取引状態** (WaitShipping / WaitReview / Done, ...)
- **発送方法** (らくらくメルカリ便, ゆうゆうメルカリ便, 大型らくらくメルカリ便, ...)
- **商品カテゴリ** (あんしんスマホサポート, あんしん自動車保証, ...)

---

Example of transactions...
<!-- TODO: 取引画面のスクリーンショット（再掲？） -->

---

- **ビジネスロジックは画面ごとに異なる**
- **共有できるコンポーネントが多くある**

---

```
src
├── common
│   └── components
│       ├── Button.tsx
│       ├── Panel.tsx
│       └── Row.tsx
└── transactions
    ├── car
    │   └── components
    ├── oogata
    │   └── components
    └── rakuraku
        ├── Buyer.tsx
        ├── Seller.tsx
        ├── components
        │   ├── ProductDetail.tsx
        │   └── TransactionInfo.tsx
        └── containers
            ├── Done.tsx
            ├── WaitReview.tsx
            └── WaitShipping.tsx
```

---

Q. How can we separate UI from business logics.

A. "Clean Architecture" in the Frontend world

  1. Presentation layer by components with styling.
  2. Presentation layer by components with domain logic.
  3. Connection layer (Redux's `connect` function)
  4. Business logic layer Redux-Saga.
  5. Data layer (Redux)

---

## Presentation layer by components with styling

「どう見えるか」を定義する層

Example:

```

```

責務が分離されているから

- コンポーネントの分離ルールが明確
- デザインシステムを適用しやすい（移行したとは言っていない）

---

## Presentation layer by components with domain logic

「何が見えるか」を定義する層

要素の出し分けをビジネスロジックを元に行う

```
```

---

## Connection layer

「振る舞い」を選ぶ層

`connect` でReducerやActionを渡して振る舞いを変更するだけ。
振る舞いの定義自体は次の層で行う。

```
```

---

## Business logic layer by Redux-Saga

「振る舞い」を定義する層

例: 「シンプル」なビジネスロジックの例

1. APIから取引情報を取ってきて保存する
2. データの取得中にはネイティブのローディングアイコンを表示する
3. 取得時にエラーが発生した場合は適切なエラーメッセージを表示する

---

## Business logic layer by Redux & Redux-Saga

```
```

---

## Data layer

Reduxはデータストアとして徹底する

例:

```
```

---

## Data layer

コツ:

- Reducerに複雑なロジックを書かない
- データごとにReducerを分離する

→ シンプルなReducerが無数に存在する状態が理想

---

## OTP (Old Transaction Page)

- 「どう見えるか」と「何が見えるか」が層分けされていない
- 振る舞いを選択する層がもない
  - 末端のコンポーネントが自分が参照すべき情報を自分で考えてグローバルオブジェクトから情報を引き抜く
  - 「」という文字列を参照するかどうかを考えるときに配送方法に応じて違うロジックをspanのvisible属性（Knockout.js)

<!-- ## マイクロサービス

- サーバーサイドではドメインの分割により責任範囲を小さくまとめる「マイクロサービス化」の潮流がある
- フロントにも「マイクロフロントエンド」という概念がある
  - モチベーションはバックエンドと同じ
  - フロントエンドはリソースを一つにまとめたいという強い要求があるため（今の所）実践は難しい -->
